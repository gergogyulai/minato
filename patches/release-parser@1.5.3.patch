diff --git a/ReleaseParser.js b/ReleaseParser.js
index b087ab0ed1592595fc7611b0447a3970a1ec1df7..d57a7ff0a03a8f0f3f17f36e1b79c076188e7c87 100644
--- a/ReleaseParser.js
+++ b/ReleaseParser.js
@@ -40,6 +40,30 @@ const ReleaseParser = /** @lends module:ReleaseParser */ ( releaseName, section
 		'country'		: null, // Release country
 		'type'			: null
 	}
+
+	// Normalize release name for consistent parsing
+	// Handle parenthesized or bracketed group notation at end: "Name (GROUP)" or "Name [GROUP]" -> "Name-GROUP"
+	
+	// Try parentheses first - look for (GROUP) with separator before
+	let groupMatch = releaseName.match( /[\s._]\(([A-Za-z0-9_.\[\]]+)\)$/ )
+	
+	// For square brackets: only convert if NOT part of an existing dash-prefixed group
+	// Skip conversion only if pattern is -WORD[...] where WORD contains no separators
+	if ( !groupMatch && !releaseName.match( /-\w+\[[^\]]+\]$/ ) )
+	{
+		groupMatch = releaseName.match( /[\s._]?\[([A-Za-z0-9_.\[\]]+)\]$/ )
+	}
+	
+	// Apply conversion if found and not purely numeric (e.g., not a year)
+	if ( groupMatch && !/^\d+$/.test( groupMatch[1] ) )
+	{
+		releaseName = releaseName.slice( 0, releaseName.length - groupMatch[0].length ) + '-' + groupMatch[1]
+	}
+	// Replace spaces with dots for uniform separator handling
+	releaseName = releaseName.replace( /\s+/g, '.' )
+	// Update stored release name so internal methods use the normalized version
+	data.release = releaseName
+
 	/**
 	 * Object toString() override: allows the object to decide how it will react when it is treated like a string.
 	 *
@@ -188,7 +212,16 @@ const ReleaseParser = /** @lends module:ReleaseParser */ ( releaseName, section
 			languageName.forEach ( (name) =>
 			{
 				// Insert current lang pattern
-				let newRegexPattern = regexPattern.replace( '%language_pattern%', name ).toRegExp()
+				let newRegexPattern = null
+
+				try
+				{
+					newRegexPattern = regexPattern.replace( '%language_pattern%', name ).toRegExp()
+				}
+				catch ( _err )
+				{
+					return
+				}
 
 				// Check for language tag (exclude "grand" for formula1 rls)
 				let matches = releaseName.match( newRegexPattern )
@@ -786,8 +819,8 @@ const ReleaseParser = /** @lends module:ReleaseParser */ ( releaseName, section
 		let type = guessTypeByParsedAttributes()
 		// 2nd: no type found? guess by section
 		type = !type ? guessTypeBySection( section ) : type
-		// 3rd: set parsed type or default to Movie
-		type = !type ? 'Movie' : type
+		// 3rd: set parsed type or default to Unknown
+		type = !type ? 'Unknown' : type
 
 		set( 'type', type )
 	}
@@ -1205,9 +1238,18 @@ const ReleaseParser = /** @lends module:ReleaseParser */ ( releaseName, section
 				// and it isn't always numeric: 8 / e8 / e08
 				if ( titleExtra && titleExtra.replaceAll( /[a-z]+/gi, '' ).isNumeric() )
 				{
+					const parsedEpisode = get( 'episode' )
+					const parsedTitleExtraEpisode = parseInt( titleExtra.replaceAll( /[a-z]+/gi, '' ) )
+					const hasEpisode =
+						Array.isArray( parsedEpisode )
+							? parsedEpisode.includes( parsedTitleExtraEpisode )
+							: typeof parsedEpisode === 'string'
+								? parsedEpisode.includes( parsedTitleExtraEpisode.toString() )
+								: parsedEpisode === parsedTitleExtraEpisode
+
 					if (
 						titleExtra.length <= 3 &&
-						get( 'episode' ).includes( parseInt( titleExtra.replaceAll( /[a-z]+/gi, '' ) ) )
+						hasEpisode
 					)
 					{
 						titleExtra = ''
@@ -1988,7 +2030,7 @@ const ReleaseParser = /** @lends module:ReleaseParser */ ( releaseName, section
 						break
 
 					case 'group':
-						attributes.push( informationValue )
+						attributes.push( escapeRegexValue( informationValue ) )
 						break
 
 					case 'language':
@@ -2103,6 +2145,18 @@ const ReleaseParser = /** @lends module:ReleaseParser */ ( releaseName, section
 		return regexPattern
 	}
 
+	/**
+	 * Escape regex special chars for dynamic values that should be matched literally.
+	 *
+	 * @private
+	 * @param {string} value - Raw value.
+	 * @return {string} Escaped value.
+	 */
+	const escapeRegexValue = ( value = '' ) =>
+	{
+		return value.toString().replace( /[.*+?^${}()|[\]\\/]/g, '\\$&' )
+	}
+
 	/**
 	 * Remove or fix attributes that were falsely parsed.
 	 *
diff --git a/ReleasePatterns.js b/ReleasePatterns.js
index 6301b495c980a5d92fd7b4f4ab708e05698fe98b..d782e726482123364039b1eacb85a0d18e05211d 100644
--- a/ReleasePatterns.js
+++ b/ReleasePatterns.js
@@ -468,6 +468,7 @@ const patterns =
 	// Release flags patterns
 	FLAGS : {
 		'3D': '3D',
+		'Ai upscale': 'Ai[._-]?upscaled?',
 		'Abridged': [ 'ABRIDGED', 'gekuerzte?(?:.(?:fassung|lesung))' ], // Audiobook
 		'Addon': 'ADDON', // software
 		'Anime': 'ANiME',
@@ -751,14 +752,14 @@ const patterns =
 
 
 	// Flags for identifying release type ( guessTypeByParsedAttributes )
-	flagsMovie : [ 'Dubbed', 'AC3 Dubbed', 'HDR', 'HDR10', 'HDR10+', 'IMAX', 'Line dubbed', 'Micro dubbed', 'THEATRICAL', 'UNCUT', 'Remux', 'Subbed', 'Directors Cut' ],
+	flagsMovie : [ 'Ai upscale', 'Dubbed', 'AC3 Dubbed', 'HDR', 'HDR10', 'HDR10+', 'IMAX', 'Line dubbed', 'Micro dubbed', 'THEATRICAL', 'UNCUT', 'Remux', 'Subbed', 'Directors Cut' ],
 	flagsEbook : [ 'Magazine', 'Comic', 'ePUB' ],
 	flagsMusic : [ 'CPOP', 'OST' ],
 	flagsApps : [ 'CRACKED', 'REGGED', 'KEYGEN', 'Incl. Patch', 'CRACKFIX', 'ISO', 'ARM', 'INTEL', 'x86', 'x64', 'Portable' ],
 	flagsGames : [ 'DLC', 'TRAiNER' ],
 	flagsAnime : [ 'Anime', 'OVA', 'ONA', 'OAD' ],
 	flagsXxx : [ 'XXX', 'JAV', 'Imageset', 'Hentai' ],
-	flagsVideo : [ 'IVTC' ],
+	flagsVideo : [ 'Ai upscale', 'IVTC' ],
 	// Formats
 	formatsVideo : [ 'AVC', 'VCD', 'SVCD', 'CVCD', 'XViD', 'DiVX', 'x264', 'x265', 'h264', 'h265', 'HEVC', 'MP4', 'MPEG', 'MPEG2', 'VC1', 'WMV' ],
 	formatsMusic : [ 'FLAC', 'KONTAKT', 'MP3', 'OGG', 'WAV' ],
