diff --git a/Users/gergo/Developer/project-minato/node_modules/release-parser/.bun-tag-57706ec7f50d80bf b/.bun-tag-57706ec7f50d80bf
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
diff --git a/Users/gergo/Developer/project-minato/node_modules/release-parser/.bun-tag-89e00f014015672c b/.bun-tag-89e00f014015672c
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
diff --git a/Users/gergo/Developer/project-minato/node_modules/release-parser/.bun-tag-97011d324ecaa73a b/.bun-tag-97011d324ecaa73a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
diff --git a/Users/gergo/Developer/project-minato/node_modules/release-parser/.bun-tag-a3b3ebe74d585824 b/.bun-tag-a3b3ebe74d585824
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
diff --git a/ReleaseParser.js b/ReleaseParser.js
index b087ab0ed1592595fc7611b0447a3970a1ec1df7..a0e56f1e258d3cfed3e30eb2ec36c3b9d4138269 100644
--- a/ReleaseParser.js
+++ b/ReleaseParser.js
@@ -40,6 +40,43 @@ const ReleaseParser = /** @lends module:ReleaseParser */ ( releaseName, section
 		'country'		: null, // Release country
 		'type'			: null
 	}
+
+	// Normalize release name for consistent parsing
+	// Handle parenthesized or bracketed group notation at end: "Name (GROUP)" or "Name [GROUP]" -> "Name-GROUP"
+	
+	// Try parentheses first - look for (GROUP) with separator before
+	let groupMatch = releaseName.match( /[\s._]\(([A-Za-z0-9_.\[\]]+)\)$/ )
+	
+	// For square brackets: only convert if NOT part of an existing dash-prefixed group
+	// Skip conversion only if pattern is -WORD[...] where WORD contains no separators
+	if ( !groupMatch && !releaseName.match( /-\w+\[[^\]]+\]$/ ) )
+	{
+		groupMatch = releaseName.match( /[\s._]?\[([A-Za-z0-9_.\[\]]+)\]$/ )
+	}
+	
+	// Apply conversion if found and not purely numeric (e.g., not a year)
+	if ( groupMatch && !/^\d+$/.test( groupMatch[1] ) )
+	{
+		releaseName = releaseName.slice( 0, releaseName.length - groupMatch[0].length ) + '-' + groupMatch[1]
+	}
+	// Normalize common P2P/torrent metadata delimiters so existing regexes can parse
+	// bracketed blocks like "[2024,.WEB-DL.1080p]" and "./." separator artifacts.
+	// Keep a standard trailing "-GROUP" suffix untouched (e.g. "-PiRaTeS[TGx]").
+	const trailingGroupMatch = releaseName.match( /-([\w.\[\]]+)$/i )
+	const trailingGroup = trailingGroupMatch ? trailingGroupMatch[0] : ''
+	let releaseNameCore = trailingGroup ? releaseName.slice( 0, -trailingGroup.length ) : releaseName
+
+	releaseNameCore = releaseNameCore
+		.replace( /\[([^\]]+)\]/g, ( _match, content ) => '.' + content.replace( /,/g, '.' ) + '.' )
+		.replace( /\.\//g, '..' )
+		.replace( /\/\./g, '..' )
+
+	releaseName = releaseNameCore + trailingGroup
+	// Replace spaces with dots for uniform separator handling
+	releaseName = releaseName.replace( /\s+/g, '.' )
+	// Update stored release name so internal methods use the normalized version
+	data.release = releaseName
+
 	/**
 	 * Object toString() override: allows the object to decide how it will react when it is treated like a string.
 	 *
@@ -188,7 +225,16 @@ const ReleaseParser = /** @lends module:ReleaseParser */ ( releaseName, section
 			languageName.forEach ( (name) =>
 			{
 				// Insert current lang pattern
-				let newRegexPattern = regexPattern.replace( '%language_pattern%', name ).toRegExp()
+				let newRegexPattern = null
+
+				try
+				{
+					newRegexPattern = regexPattern.replace( '%language_pattern%', name ).toRegExp()
+				}
+				catch ( _err )
+				{
+					return
+				}
 
 				// Check for language tag (exclude "grand" for formula1 rls)
 				let matches = releaseName.match( newRegexPattern )
@@ -786,8 +832,8 @@ const ReleaseParser = /** @lends module:ReleaseParser */ ( releaseName, section
 		let type = guessTypeByParsedAttributes()
 		// 2nd: no type found? guess by section
 		type = !type ? guessTypeBySection( section ) : type
-		// 3rd: set parsed type or default to Movie
-		type = !type ? 'Movie' : type
+		// 3rd: set parsed type or default to Unknown
+		type = !type ? 'Unknown' : type
 
 		set( 'type', type )
 	}
@@ -1175,7 +1221,7 @@ const ReleaseParser = /** @lends module:ReleaseParser */ ( releaseName, section
 
 			// Only needed here for releases that have episodes
 			// Maybe year is before episode and have to be removed
-			let releaseNameNoYear = cleanup( releaseNameCleaned, [ 'disc', 'format', 'year' ] )
+			let releaseNameNoYear = cleanup( releaseNameCleaned, [ 'disc', 'format', 'season', 'year' ] )
 
 			// Match title
 			matches = releaseNameNoYear.match( regexPattern )
@@ -1205,9 +1251,18 @@ const ReleaseParser = /** @lends module:ReleaseParser */ ( releaseName, section
 				// and it isn't always numeric: 8 / e8 / e08
 				if ( titleExtra && titleExtra.replaceAll( /[a-z]+/gi, '' ).isNumeric() )
 				{
+					const parsedEpisode = get( 'episode' )
+					const parsedTitleExtraEpisode = parseInt( titleExtra.replaceAll( /[a-z]+/gi, '' ) )
+					const hasEpisode =
+						Array.isArray( parsedEpisode )
+							? parsedEpisode.includes( parsedTitleExtraEpisode )
+							: typeof parsedEpisode === 'string'
+								? parsedEpisode.includes( parsedTitleExtraEpisode.toString() )
+								: parsedEpisode === parsedTitleExtraEpisode
+
 					if (
 						titleExtra.length <= 3 &&
-						get( 'episode' ).includes( parseInt( titleExtra.replaceAll( /[a-z]+/gi, '' ) ) )
+						hasEpisode
 					)
 					{
 						titleExtra = ''
@@ -1825,6 +1880,10 @@ const ReleaseParser = /** @lends module:ReleaseParser */ ( releaseName, section
 						attributes.push( patterns.RESOLUTION[ informationValue ] )
 						break
 
+					case 'season':
+						attributes.push( '(?:season|saison|staffel|temp)[._-]?0?' + informationValue )
+						break
+
 					case 'source':
 						if ( Array.isArray( informationValue ) )
 						{
@@ -1988,7 +2047,7 @@ const ReleaseParser = /** @lends module:ReleaseParser */ ( releaseName, section
 						break
 
 					case 'group':
-						attributes.push( informationValue )
+						attributes.push( escapeRegexValue( informationValue ) )
 						break
 
 					case 'language':
@@ -2103,6 +2162,18 @@ const ReleaseParser = /** @lends module:ReleaseParser */ ( releaseName, section
 		return regexPattern
 	}
 
+	/**
+	 * Escape regex special chars for dynamic values that should be matched literally.
+	 *
+	 * @private
+	 * @param {string} value - Raw value.
+	 * @return {string} Escaped value.
+	 */
+	const escapeRegexValue = ( value = '' ) =>
+	{
+		return value.toString().replace( /[.*+?^${}()|[\]\\/]/g, '\\$&' )
+	}
+
 	/**
 	 * Remove or fix attributes that were falsely parsed.
 	 *
@@ -2183,6 +2254,43 @@ const ReleaseParser = /** @lends module:ReleaseParser */ ( releaseName, section
 			set( 'flags', null )
 		}
 
+		// Whole-season TV packs can bleed season tokens into title/titleExtra when title parsing
+		// falls back to generic patterns.
+		if ( type === 'tv' && _title && get( 'season' ) && !get( 'episode' ) )
+		{
+			const seasonNumber = get( 'season' ).toString()
+			const seasonSuffix = new RegExp( `\\s+(?:season|saison|staffel|temp)\\s*0*${seasonNumber}$`, 'i' )
+			if ( seasonSuffix.test( _title ) )
+			{
+				_title = _title.replace( seasonSuffix, '' ).trim()
+				set( 'title', _title || get( 'title' ) )
+			}
+
+			const releaseValue = get( 'release' ) || ''
+			const seasonRangeWord = releaseValue.match( /(?:^|[._(-])(?:season|saison|staffel|temp)[._-]?0*(\d+)[._-]+0*(\d+)(?=[._)-])/i )
+			const seasonRangeShort = releaseValue.match( /(?:^|[._(-])s0*(\d+)[._-]+s0*(\d+)(?=[._)-])/i )
+			const titleExtra = get( 'titleExtra' )
+			const rangeEnd = seasonRangeShort ? seasonRangeShort[2] : seasonRangeWord ? seasonRangeWord[2] : null
+
+			if ( rangeEnd && titleExtra )
+			{
+				const extraLooksLikeSeasonRangeEnd = new RegExp( `^s0*${rangeEnd}(?:\\b|\\s|\\()`, 'i' )
+
+				if ( extraLooksLikeSeasonRangeEnd.test( titleExtra ) )
+				{
+					set( 'titleExtra', null )
+
+					// If the upper bound of "Season 1-5" bled into the title, strip only the extra trailing token.
+					const titleWithRangeBleed = new RegExp( `\\s+0*${rangeEnd}$` )
+					const currentTitle = get( 'title' )
+					if ( seasonRangeWord && currentTitle && titleWithRangeBleed.test( currentTitle ) )
+					{
+						set( 'title', currentTitle.replace( titleWithRangeBleed, '' ).trim() )
+					}
+				}
+			}
+		}
+
 		if ( type === 'movie' || type === 'xxx' || type === 'tv' )
 		{
 			// Change source DVD/Bluray to format DVDR if no res and format given
diff --git a/ReleasePatterns.js b/ReleasePatterns.js
index 6301b495c980a5d92fd7b4f4ab708e05698fe98b..c1fb56a6a4e67d32da42249f34d1e2eb893f67b0 100644
--- a/ReleasePatterns.js
+++ b/ReleasePatterns.js
@@ -43,7 +43,7 @@ const patterns =
 	// For Disc numbers: Disc1 / DVD1 / CD1 / (S01)D01
 	REGEX_DISC : regexDisc,
 	// Season pattern matches: S01E01 / 1x01 / S01D01
-	REGEX_SEASON : '/[._-](?:(?:[ST]|saison[._-]?|staffel[._-]?|temp[._-]?)(\\d+)[._-]?(?:(?:ep?|eps[._-]?|episode[._-]?|f(?:olge[._-]?)|d|di[cks][cks]|cd|dvd)\\d+)?|(\\d+)(?:x\\d+))[._-]/i',
+	REGEX_SEASON : '/[._-](?:(?:[ST]|season[._-]?|saison[._-]?|staffel[._-]?|temp[._-]?)(\\d+)[._-]?(?:(?:ep?|eps[._-]?|episode[._-]?|f(?:olge[._-]?)|d|di[cks][cks]|cd|dvd)\\d+)?|(\\d+)(?:x\\d+))[._-]/i',
 	// Basic title pattern
 	REGEX_TITLE : regexTitle,
 	// Good for Ebooks
@@ -468,6 +468,7 @@ const patterns =
 	// Release flags patterns
 	FLAGS : {
 		'3D': '3D',
+		'Ai upscale': 'Ai[._-]?upscaled?',
 		'Abridged': [ 'ABRIDGED', 'gekuerzte?(?:.(?:fassung|lesung))' ], // Audiobook
 		'Addon': 'ADDON', // software
 		'Anime': 'ANiME',
@@ -751,14 +752,14 @@ const patterns =
 
 
 	// Flags for identifying release type ( guessTypeByParsedAttributes )
-	flagsMovie : [ 'Dubbed', 'AC3 Dubbed', 'HDR', 'HDR10', 'HDR10+', 'IMAX', 'Line dubbed', 'Micro dubbed', 'THEATRICAL', 'UNCUT', 'Remux', 'Subbed', 'Directors Cut' ],
+	flagsMovie : [ 'Ai upscale', 'Dubbed', 'AC3 Dubbed', 'HDR', 'HDR10', 'HDR10+', 'IMAX', 'Line dubbed', 'Micro dubbed', 'THEATRICAL', 'UNCUT', 'Remux', 'Subbed', 'Directors Cut' ],
 	flagsEbook : [ 'Magazine', 'Comic', 'ePUB' ],
 	flagsMusic : [ 'CPOP', 'OST' ],
 	flagsApps : [ 'CRACKED', 'REGGED', 'KEYGEN', 'Incl. Patch', 'CRACKFIX', 'ISO', 'ARM', 'INTEL', 'x86', 'x64', 'Portable' ],
 	flagsGames : [ 'DLC', 'TRAiNER' ],
 	flagsAnime : [ 'Anime', 'OVA', 'ONA', 'OAD' ],
 	flagsXxx : [ 'XXX', 'JAV', 'Imageset', 'Hentai' ],
-	flagsVideo : [ 'IVTC' ],
+	flagsVideo : [ 'Ai upscale', 'IVTC' ],
 	// Formats
 	formatsVideo : [ 'AVC', 'VCD', 'SVCD', 'CVCD', 'XViD', 'DiVX', 'x264', 'x265', 'h264', 'h265', 'HEVC', 'MP4', 'MPEG', 'MPEG2', 'VC1', 'WMV' ],
 	formatsMusic : [ 'FLAC', 'KONTAKT', 'MP3', 'OGG', 'WAV' ],
